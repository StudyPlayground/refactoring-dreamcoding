# Day5
> 11.API 리팩터링   
> 12.상속 다루기

<br>

## 📌문제1
### 다음 코드의 출력 결과가 동일하도록 리팩터링 하시오.
```js
class Study {
  constructor(name, count, type) {
    this._name = name;
    this._count = count;
    this._type = type;
    this._state = recruitingState(this._count);
  }

  get count() {
    return this._count;
  }

  get type() {
    return this._type;
  }

  get count() {
    return this._count;
  }

  set count(arg) {
    this._count = arg;
    this._state = recruitingState(this._count);
  }

  toString() {
    return `${this._name} is ${this._state} (${this._count})`;
  }
}

function recruitingState(count) {
  if (10 < count) {
    return "Full";
  } else if (5 < count) {
    return "Almost Full";
  } else {
    return "Hiring";
  }
}

function compareByCount(study1, study2) {
  return study1.count - study2.count;
}

const studys = [
  new Study("typeScript_study", 5, "Book"),
  new Study("network_study", 10, "CS"),
  new Study("javascript_deep_diver", 1, "Book"),
  new Study("coding_test", 3, "Algorithm"),
  new Study("refactoring_study", 12, "Book"),
  new Study("Reading_Book", 6, "Book"),
  new Study("Database_study", 9, "CS"),
];

console.log("<정렬 전>");
studys.forEach((study) => console.log(study.toString()));

console.log("<정렬 기준: count>");
studys.sort(compareByCount).forEach((study) => console.log(study.toString()));
```

<br>

## 📌문제2
### 다음 코드의 출력 결과가 동일하도록 리팩터링 하시오.
```js
class SmartPhone {
  #name;
  constructor(name) {
    this.#name = name;
  }
}

class CameraPhone extends SmartPhone {
  #pixel;
  constructor(name, pixel) {
    super(name);
    this.#pixel = pixel;
  }
  takePicture() {
    return "찰칵";
  }
}

class NetworkPhone extends SmartPhone {
  #speed;
  constructor(name, speed) {
    super(name);
    this.#speed = speed;
  }
}

class CameraNetworkPhone extends SmartPhone {
  #pixel;
  #speed;
  constructor(name, pixel, speed) {
    super(name);
    this.#pixel = pixel;
    this.#speed = speed;
  }
  takePicture() {
    return "찰칵";
  }
}
```

<br>
